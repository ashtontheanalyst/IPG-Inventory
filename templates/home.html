<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <link rel="stylesheet" href="../static/index.css"><!--CSS-->
</head>
<body>
    <!--Header-->
    <div id="headerBar">
        <a href="/" style="text-decoration: none;"><h1>IPG Inventory</h1></a>

        <div id="headerBtnCont">
            <button id="ResetInvBtn" type="button" onclick="resetInvCol()" class="headerBtn" title="Reset Page">
                <img src="../static/assets/reset.svg" alt="Reset" style="width: 35px;">
            </button>
            <button id="generate2062Btn" type="button" class="headerBtn" onclick="generate2062()" title="Generate 2062HR">
                <img src="../static/assets/document.svg" alt="2062" style="width: 40px;">
            </button>
            <a href="/scannerHelp" class="headerBtn" id="scannerBtn" title="Help">
                <img src="../static/assets/help.svg" alt="Help" style="width: 37px;">
            </a>
            <a href="/info" class="headerBtn" id="infoBtn" title="Get Item Information">
                <img src="../static/assets/info.svg" alt="Info" style="width: 32px;">
            </a>
        </div>
    </div>


    <div id="main">
        <div id="optBtnsCont">
            <!--Location btn, goes from Location, to RIC, to OTA, to MCC, then back-->
            <button id="filterLocBtn" type="button" class="optBtn" onclick="filterLocBtnToggle()"></button>

            <!--Sort name A-Z then Z-A-->
            <button id="sortNameBtn" type="button" class="optBtn" onclick="sortNameBtnToggle()"></button>

            <!--This button adds the last seen column to the table (toggelable)-->
            <button id="lastSeenBtn" type="button" class="optBtn" value="unselected" onclick="lastSeenBtnToggle()">Seen</button>
            <button id="maintBtn" type="button" class="optBtn" value="unselected" onclick="maintBtnToggle()">Maint</button>
            <button id="holderBtn" type="button" class="optBtn" value="unselected" onclick="holderBtnToggle()">Holder</button>
        </div>


        <table id="inventory"></table>


        <!-- This is the input from the scanner, we make it 100% opaque and off the screen hidden -->
        <input id="scannerInput" type="text" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" tabindex="0"
        style="position: fixed; bottom: 0; left: 0; width: 1px; height: 1px; opacity: 0.01; z-index: 9999; border: none; color: transparent; caret-color: transparent;">
    </div>
</body>
</html>

<!--This is the main site logic-->
<script>
    const scannerBtn = document.getElementById("scannerBtn");
    const inventory = document.getElementById("inventory");
    const scannerInput = document.getElementById("scannerInput");


    // Default values for toggle buttons (value changes as you click it)
    const sortNameBtn = document.getElementById("sortNameBtn");
    const filterLocBtn = document.getElementById("filterLocBtn");
    const lastSeenBtn = document.getElementById("lastSeenBtn");
    let lastSeenToggle = false;       // This toggles on or off to determine if it's shown on the table
    const maintBtn = document.getElementById("maintBtn");
    let maintToggle = false;          // Same idea as above but shows maintenance date
    const holderBtn = document.getElementById("holderBtn");
    let holderToggle = false; 
    const generate2062Btn = document.getElementById("generate2062Btn");
    sortNameBtn.innerHTML = "Sort";
    filterLocBtn.innerHTML = "Location";




    // This is what loads on initial visiting the home page, pulls inventory CSV to frontend then passes
    // it to the build table func
    async function getTableData() {
        const response = await fetch(`/getTable`);
        const data = await response.json();

        // Helper function to build table
        buildTable(data);
    }

    // Helper function that builds the table itself with data from backend CSV
    function buildTable(data) {
        inventory.innerHTML = "";   // Clear

        // Headers
        const thead = document.createElement("thead");
        const hr = document.createElement("tr");
        let headers = ["Item", "S/N", "LOC", "S"];    // Base

        // Extras if selected
        if (lastSeenToggle) {
            headers.push("Last");
        }
        if (maintToggle) {
            headers.push("Maint Due");
        }
        if (holderToggle) {
            headers.push("Holder");
        }
        
        headers.forEach((val) => {
            const th = document.createElement("th");
            th.textContent = val;
            hr.appendChild(th);
        });
        thead.appendChild(hr);
        inventory.appendChild(thead);


        // Adding our rows (items)
        const tbody = document.createElement("tbody");
        data.items.forEach((item) => {
            // This builds each individual row and appends to the body which appends to the table
            const tr = document.createElement("tr");
            tr.insertCell(0).textContent = item.name;
            tr.insertCell(1).textContent = item.serial;
            tr.insertCell(2).textContent = item.location;
            tr.insertCell(3).textContent = item.inventoried;

            // Our optionals
            if (maintToggle) {
                tr.insertCell(4).textContent = item.maintenance;
            } else if (lastSeenToggle) {
                tr.insertCell(4).textContent = item.lastSeen;
            } else if (holderToggle) {
                const td = tr.insertCell(4);
                td.textContent = item.holder;
                // Each holder cell in this column gets CSS so it'll light up/be selectable for later use
                td.classList.add("holder-cell");
            }

            // This highlights the items that are inventoried, lights up the row
            if (item.inventoried == "T") {
                tr.classList.add("inventoriedRow"); // CSS defines the class
            }

            tbody.appendChild(tr);
        });
        inventory.appendChild(tbody);
    }




    // Sort the table/items A-Z or Z-A
    async function sortTable(direction, location) {
        const response = await fetch(`/sortTable?direction=${direction}&location=${location}&seen=${lastSeenToggle}&maint=${maintToggle}`);
        const data = await response.json();
        buildTable(data);
    }

    function sortNameBtnToggle() {
        let direction = sortNameBtn.innerHTML;
        let location = filterLocBtn.innerHTML;

        if (direction == "Sort") {
            sortTable("A", location);
            sortNameBtn.innerHTML = "A-Z";
        }
        else if (direction == "A-Z") {
            sortTable("D", location);
            sortNameBtn.innerHTML = "Z-A";
        }
        else if (direction == "Z-A") {
            sortTable("A", location);
            sortNameBtn.innerHTML = "A-Z";
        }
    }




    // Filters the item in the table based on location you specify on btn press
    async function filterTable(location) {
        const response = await fetch(`/filterTable?location=${location}&seen=${lastSeenToggle}&maint=${maintToggle}`);
        const data = await response.json();
        buildTable(data);
    }

    function filterLocBtnToggle() {
        let location = filterLocBtn.innerHTML;

        // Reset the A-Z/Z-A btn each time we change location for easier logic
        sortNameBtn.innerHTML = "Sort";

        if (location == "Location") {
            filterTable("RIC");
            filterLocBtn.innerHTML = "RIC";
        }
        else if (location == "RIC") {
            filterTable("OTA");
            filterLocBtn.innerHTML = "OTA";
        }
        else if (location == "OTA") {
            filterTable("MCC");
            filterLocBtn.innerHTML = "MCC";
        }
        else if (location == "MCC") {
            filterTable("Location");
            filterLocBtn.innerHTML = "Location";
        }
    }




    async function getTableLastSeen(location) {
        const response = await fetch(`/getTableLastSeen?location=${location}`);
        const data = await response.json();
        buildTable(data);
    }
    
    // This toggles the lastSeen btn which inserts a column onto the inventory table showing
    // the date of the last time that object was scanned
    function lastSeenBtnToggle() {
        // Either "selected" or "unselected"
        let state = lastSeenBtn.value;
        let location = filterLocBtn.innerHTML;

        if (state == "unselected") {
            lastSeenBtn.classList.toggle("seen-active");
            lastSeenBtn.value = "selected";
            lastSeenToggle = true;

            // Turn off other btns
            maintToggle = false;
            maintBtn.value = "unselected";
            maintBtn.classList.remove("seen-active");

            holderToggle = false;
            holderBtn.value = "unselected";
            holderBtn.classList.remove("seen-active");

            getTableLastSeen(location);
        }
        else if (state == "selected") {
            lastSeenBtn.classList.toggle("seen-active");
            lastSeenBtn.value = "unselected";
            lastSeenToggle = false;
            filterTable(location);      // Load in the regular inventory without the extra column
        }
    }




    // Same logic/design as lastSeenBtnToggle() 
    async function getTableMaintenance(location) {
        const response = await fetch(`/getTableMaintenance?location=${location}`);
        const data = await response.json();
        buildTable(data);
    }

    function maintBtnToggle() {
        // Either "selected" or "unselected"
        let state = maintBtn.value;
        let location = filterLocBtn.innerHTML;

        if (state == "unselected") {
            maintBtn.classList.toggle("seen-active");
            maintBtn.value = "selected";
            maintToggle = true;

            // Turn off other btns
            lastSeenToggle = false;
            lastSeenBtn.value = "unselected";
            lastSeenBtn.classList.remove("seen-active");

            holderToggle = false;
            holderBtn.value = "unselected";
            holderBtn.classList.remove("seen-active");

            getTableMaintenance(location);
        }
        else if (state == "selected") {
            maintBtn.classList.toggle("seen-active");
            maintBtn.value = "unselected";
            maintToggle = false;
            filterTable(location);
        }
    }




    // This column will show who the last holder of the item was
    async function getTableHolder(location) {
        const response = await fetch(`/getTableHolder?location=${location}`);
        const data = await response.json();
        buildTable(data);
    }

    function holderBtnToggle() {
        // Either "selected" or "unselected"
        let state = holderBtn.value;
        let location = filterLocBtn.innerHTML;

        if (state == "unselected") {
            holderBtn.classList.toggle("seen-active");
            holderBtn.value = "selected";
            holderToggle = true;

            // Turn off the "Last Seen" button to free up the column, acts like a radio btn
            lastSeenToggle = false;
            lastSeenBtn.value = "unselected";
            lastSeenBtn.classList.remove("seen-active");

            maintToggle = false;
            maintBtn.value = "unselected";
            maintBtn.classList.remove("seen-active");

            getTableHolder(location);
        }
        else if (state == "selected") {
            holderBtn.classList.toggle("seen-active");
            holderBtn.value = "unselected";
            holderToggle = false;
            filterTable(location);
        }
    }


    // This is fired off when we click on a highlighted cell of the holder column, it allows
    // the user to edit the name/entity of who had the item last
    document.addEventListener("click", (cell) => {
        if (cell.target.classList.contains("holder-cell")) {
            // This grabs the item name and serial of the row that was selected
            item = cell.target.parentElement.cells[0].textContent;
            serial = cell.target.parentElement.cells[1].textContent;

            // Prompt the user to enter a name of who the new item holder is
            name = window.prompt(`Enter the last holder of:\nItem: ${item}\nSerial: ${serial}`);
            
            // Update the sheet, we take in blank input because that would be the same as "deleting"
            changeHolder(name, item, serial);
        }
    });

    async function changeHolder(name, item, serial) {
        const response = await fetch(`/changeHolder?name=${name}&item=${item}&serial=${serial}&location=${filterLocBtn.innerHTML}&seen=${lastSeenToggle}&maint=${maintToggle}`);
        const data = await response.json();
        buildTable(data);
    }




    // Scanning/inventorying functionality
    async function markPresent(value, location) {
        const response = await fetch(`/markPresent?value=${value}&location=${location}&seen=${lastSeenToggle}&maint=${maintToggle}`, {
            headers: {'Accept': 'application/json'},
            cache: 'no-store'
        });
        const data = await response.json();
        buildTable(data);
    }

    // Remember, when the scanner scans something, it acts like a keyboard typing in letters
    // super fast. So, we pick up that input here
    scannerInput.addEventListener('keydown', async (event) => {
        let location = filterLocBtn.innerHTML;

        // When the scanner is done scanning, it clicks enter
        if (event.key === "Enter") {
            // Mark that the item has been inventoried in the backend csv
            const value = scannerInput.value.trim();
            await markPresent(value, location);

            // To show a successful scan/item grab, we change the btn class to flash, wait, then reset the style
            scannerBtn.classList.add('flashSuccess');
            setTimeout(() => scannerBtn.classList.remove('flashSuccess'), 200);

            // Clear the scanner input
            scannerInput.value = "";
        }
    });

    


    // Resets the inventoried column to all "FALSE" values
    async function resetInvCol() {
        const response = await fetch(`/resetInvCol`);
        const data = await response.json();

        // Reset out filter/sort btns
        filterLocBtn.innerHTML = "Location";
        sortNameBtn.innerHTML = "Sort";

        // Reset optns btns
        lastSeenToggle = false;
        lastSeenBtn.value = "unselected";
        lastSeenBtn.classList.remove("seen-active");
        maintToggle = false;
        maintBtn.value = "unselected";
        maintBtn.classList.remove("seen-active");
        holderToggle = false;
        holderBtn.value = "unselected";
        holderBtn.classList.remove("seen-active");

        buildTable(data);
    }




    // Helper function to bring focus back to the scannerinput
    function focusScanner() {
        if (document.activeElement !== scannerInput) {
            scannerInput.focus();
        }
    }

    // Events to fire helper
    window.addEventListener("load", focusScanner);      // When the page loads
    window.addEventListener("focus", focusScanner);     // When you come back to the page
    document.addEventListener("mousedown", (e) => {      // Mouse click
        // This makes sure we can interact with say a button and not get interrupted
        if (e.target.closest('button')) {
            return;
        }

        setTimeout(focusScanner, 0);
    });

    // Reset focus after we click on something on screen
    document.addEventListener("click", () => {
        setTimeout(focusScanner, 0);
    });

    // This is for touch screens, resets the focus to the scanner input after you tap
    document.addEventListener('touchstart', (e) => {
        if (!e.target.closest('button, a, input, label, select, textarea, [role="button"]')) {
            setTimeout(focusScanner, 0);
            }
    });




    // 2062 generation
    async function generate2062() {
        // First prompt the user to enter who the 2062 is for (client)
        const client = window.prompt("Who is this 2062 being given to (client/entity name):");

        // If the input is junk or blank then don't make a 2062
        if (!client || !client.trim()) {
            window.alert("You must specify who the 2062 is for.");
            return;
        }

        // Grab the 2062 Docx
        const response = await fetch(`/get2062?client=${client}`);
        const blob = await response.blob();

        // Download to the client
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `Generated2062.docx`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
    }




    // Build the table once window loads
    window.addEventListener("DOMContentLoaded", getTableData)
</script>